"# wtf-file-vimrc
"## Vimproved
"wtf-vimproved

set nocompatible

"## Buffer
"wtf-buffer

set hidden

set encoding=utf-8

set autoread
autocmd FocusGained,BufEnter * :silent!<space>!

"## Aparência e som
"wtf-aparencia

colorscheme slate
set background=dark
set t_Co=256
set termguicolors
set noerrorbells novisualbell t_vb=
set belloff=all
set conceallevel=2

set t_ut=""
if (&term =~ '^xterm' && &t_Co == 256)
   set t_ut= | set ttyscroll=1
endif

"## Comportamento
"wtf-comportamento

syntax on

filetype plugin indent on
set showmatch                   
set showmode                    
set showcmd                     
set autoindent                  
set mouse=                      
set linebreak                   
set nocursorcolumn nocursorline 
set number norelativenumber     
set nrformats-=octal            
set lazyredraw                  
set nobackup                    
set noswapfile                  
set scrolloff=3                 
set clipboard^=unnamedplus,unnamed
set colorcolumn=
set backspace=indent,eol,start
set formatoptions+=jcr
set hlsearch   
set incsearch  
set ignorecase 
set nosmartcase
set noemoji
set renderoptions=
set modeline
set modelines=5
set tabstop=4
set softtabstop=4
set shiftwidth=4
set smarttab
set expandtab
set foldmethod=marker
set foldtext=FoldTextMarker()
set fillchars=vert:\|,fold:─

let g:html_dynamic_folds=1
let g:html_prevent_copy = "fntd"

function! FoldTextMarker()
    let lines_count = v:foldend - v:foldstart + 1

    let lines_count_text = '┤' . printf("%4s", lines_count) . '├'
    let foldchar = matchstr(&fillchars, 'fold:\zs.')

    let titulo = substitute(getline(v:foldstart), "^[#*{\/ \"<!--]*", "", 'g')
    let titulo = substitute(titulo, "\*\/*$", "", 'g')
    let titulo = substitute(titulo, "\-\-\>*$", "", 'g')
    let titulo = substitute(titulo, "\ *$", "", 'g')

    let foldtextstart = repeat('+', v:foldlevel) . ' ' . titulo

    let foldtextend = lines_count_text . repeat(foldchar, 8)
    let foldtextlength = strlen(substitute(foldtextstart . foldtextend, '.', 'x', 'g')) + &foldcolumn
    return foldtextstart  . ' ' . repeat(foldchar, winwidth(0)-foldtextlength) . foldtextend
endfunction

let g:netrw_liststyle=3
let g:netrw_bufsettings = 'noma nomod nu nobl nowrap ro'
set shellslash

"### Autocomplete
"wtf-autocomplete

set wildmenu
set shortmess+=c
set wildcharm=<tab>
set completeopt=menuone,noinsert,noselect

set wildignore=.git,.git/**
set wildignore+=.svn,.svn/**
set wildignore+=node_modules,node_modules/**
set wildignore+=.venv,*/*_cache/*
set wildignore+=dist,dist/**
set wildignore+=target,target/**
set wildignore+=build,build/**
set wildignore+=vendor,vendor/**
set wildignore+=ios,ios/**
set wildignore+=android,android/**
set wildignore+=_site,_site/**
set wildignore+=*/coverage,*/coverage/**
set wildignore+=*/_reports,*/_reports/**
set wildignore+=*/_gen
set wildignore+=DS_Store,DS_Store/**
set wildignore+=tags
set wildignore+=.next

set wildignorecase

set complete=.,k,w,t

set tags=tags

set omnifunc=syntaxcomplete#Complete

"## Statusline
"wtf-statusline

set laststatus=2
set statusline=
set statusline+=\ %f\ %r\%m
set statusline+=\%=
set statusline+=\ %p%%\ %l:\%c
set statusline+=\ %y

"## Funções
"wtf-funcoes

function! NN_ctags()
    let s:ctags_command="ctags" . 
                \ " -R --totals" .
                \ " --exclude=.git --exclude=.svn" .
                \ " --exclude=vendor --exclude=_*" .
                \ " --exclude=*_cache" .
                \ " --exclude=node_modules --exclude=dist --exclude=build --exclude=ios --exclude=android" .
                \ " --exclude=_site" .
                \ " --php-kinds=cfvit" .
                \ " --python-kinds=-i" .
                \ " --languages=php,javascript,python"

    if filereadable(expand(".ctags"))
        let s:ctags_command.=" --options=.ctags"
    endif

    let s:ctags_command.=" ."

    execute "!".s:ctags_command
endfun

function! NN_EmojiToggle()
    if &renderoptions == ""
        set renderoptions=type:directx,gamma:1.0,contrast:0.1,level:1.0,geom:1,renmode:5,taamode:1
    else
        set renderoptions=
    endif
endfun

function! NN_SetGitDir()
    cd %:p:h
    let gitdir=system("git rev-parse --show-toplevel")
    let isnotgitdir=matchstr(gitdir, '^fatal:.*')
    if empty(isnotgitdir)
        cd `=gitdir`
    endif
endfunction

function! NN_Lexplorer()
    call NN_SetGitDir()
    Lexplore
endfunction

function! NN_Tasks()
    call NN_SetGitDir()
    vimgrep /\C\<TODO\>\|\C\<FIXME\>/j **
    copen
endfunction

function! NN_GitAula()
    let log = system("git log --pretty=format:\%s")
    vnew
    put=log
    normal! gg
    if search('^:tv: add aula')>0
        normal! 3W
        let s:numero_aula = expand('<cword>')+1
        echom system("git add -A && git commit -m \":tv: add aula ".s:numero_aula."\"")
    else
        echom system("git add -A && git commit -m \":tv: add aula 1\"")
    endif
    bdelete!
endfunction

function! NN_GitAula2()
    let log = system("git log --pretty=format:\%s")
    vnew
    put=log
    normal! gg
    if search('^:zap: add aula')>0
        normal! 3W
        let s:numero_aula = expand('<cword>')+1
        echom system("git add -A && git commit -m \":zap: add aula ".s:numero_aula."\"")
    else
        echom system("git add -A && git commit -m \":zap: add aula 1\"")
    endif
    bdelete!
endfunction

function! s:FechaSplitOuDeletaBuffer()
    if winnr('$') > 1
        q
    else
        bd
    endif
endfunction

function! s:FechaSplitOuDeletaBufferForced()
    if winnr('$') > 1
        q!
    else
        bd!
    endif
endfunction

function! s:AutoCompleteCarinhas()
    call complete(col('.'), [
                \ 'ಥ_ಥ',
                \ 'ლ(ಠ益ಠლ)',
                \ 'ಠ╭╮ಠ',
                \ '(╯°□°)╯︵ ʞooqǝɔɐɟ',
                \ '(╯°□°)╯︵ ┻━┻',
                \ '(╮°-°)╮┳━┳',
                \ '( ͡° ͜ʖ ͡°)',
                \ '¯\_(ツ)_/¯',
                \ '(~˘▾˘)~',
                \ 'ᕦ(ò_óˇ)ᕤ',
                \ '༼ つ ◕_◕ ༽つ',
                \])
    return ''
endfunction

let s:comment_map = { 
            \   "c": '\/\/',
            \   "cpp": '\/\/',
            \   "dot": '\/\/',
            \   "go": '\/\/',
            \   "java": '\/\/',
            \   "javascript": '\/\/',
            \   "javascriptreact": '\/\/',
            \   "typescript": '\/\/',
            \   "typescriptreact": '\/\/',
            \   "vue": '\/\/',
            \   "lua": '--',
            \   "scala": '\/\/',
            \   "php": '\/\/',
            \   "python": '#',
            \   "ruby": '#',
            \   "rust": '\/\/',
            \   "scss": '\/\/',
            \   "sass": '\/\/',
            \   "sh": '#',
            \   "bashrc": '#',
            \   "vim": '"',
            \ }

function! s:ToggleComment()
    if has_key(s:comment_map, &filetype)
        let comment_leader = s:comment_map[&filetype]
        if getline('.') =~ "^\\s*" . comment_leader . " " 
            " Uncomment
            execute "silent s/^\\(\\s*\\)" . comment_leader . " /\\1/"
        else 
            if getline('.') =~ "^\\s*" . comment_leader
                " Uncomment
                execute "silent s/^\\(\\s*\\)" . comment_leader . "/\\1/"
            else
                " Comment
                execute "silent s/^\\(\\s*\\)/\\1" . comment_leader . " /"
                " execute "silent s/^/\\1" . comment_leader . " /"
            end
        end
    end
endfunction

"## Comandos

command! Sov w | source $MYVIMRC | e %

command! -nargs=* Cake make! <args> | cw
command! -nargs=* Lake make! <args> | cw

command! BufOnly execute 'kb|%bdelete|e #|b#|bd%|normal `b'

command! TerminalGitRootVertical exec 'call NN_SetGitDir() | vert term ++kill=term'
command! TerminalGitRootHorizontal exec 'call NN_SetGitDir() | term ++kill=term'

command! Syntax echo "hi<" . synIDattr(synID(line("."),col("."),1),"name") . '> trans<' . synIDattr(synID(line("."),col("."),0),"name") . "> lo<" . synIDattr(synIDtrans(synID(line("."),col("."),1)),"name") . ">"

"## Mapeamentos

let mapleader="\<space>"

nnoremap    <leader><leader>    :w<CR>
nnoremap    <leader><cr>        :call NN_Lexplorer()<cr>
nnoremap    <leader>/           :noh<cr>
nnoremap    <leader>.           :pwd<CR>
nnoremap    <leader>dd          :call <SID>FechaSplitOuDeletaBuffer()<CR>
nnoremap    <leader>df          :call <SID>FechaSplitOuDeletaBufferForced()<CR>
nnoremap    <leader>ds          :on<CR>| " Close all splits
nnoremap    <leader>j           <c-w>w|" estilo DWM
nnoremap    <leader>k           <c-w>W|" estilo DWM
nnoremap    <leader>n           :call NN_<c-d>| " funções pessoais
vnoremap    <leader>n           :call NN_<c-d>| " funções pessoais
nnoremap    <expr><leader>q     empty(filter(getwininfo(), 'v:val.quickfix')) ? ":cope<CR>" : ":ccl<CR>"
nnoremap    <expr><leader>l     empty(filter(getwininfo(), 'v:val.loclist')) ? ":lope<CR>" : ":lcl<CR>"
nnoremap    <leader>s           :split<CR>
nnoremap    <leader>t           :tj <c-r><c-w><CR>| " Goto definition (ctags)
nnoremap    <leader>v           :vsplit<CR>
nnoremap    <leader>y           my^vg_"+y:echo "Copiado!!"<CR>
vnoremap    <leader>y           "+y:echo "Copiado!!"<CR>
nnoremap    <leader>z           za

nnoremap    !!          :!!<CR>
nnoremap    #           :b #<CR>|" FIXME volta para unlisted buffer tbm
vnoremap    <           <gv|" mantêm select após indentação
vnoremap    >           >gv|" mantêm select após indentação
inoremap    "           ""<left>|"autoclose
inoremap    '           ''<left>|"autoclose
inoremap    {           {}<left>|"autoclose
inoremap    {}          {}|"evitar {}}
inoremap    {<CR>       {}<left><CR><Esc>O|"autoclose
inoremap    {<space>    {}<left><space><space><left>|"autoclose
inoremap    (           ()<left>|"autoclose
inoremap    ()          ()|"evitar ())
inoremap    (<CR>       ()<left><CR><Esc>O|"autoclose
inoremap    (<space>    ()<left><space><space><left>|"autoclose
inoremap    [           []<left>|"autoclose
inoremap    []          []|"evitar []]
inoremap    [<CR>       []<left><CR><Esc>O|"autoclose
inoremap    [<space>    []<left><space><space><left>|"autoclose
nnoremap    gc          :call <SID>ToggleComment()<CR>
vnoremap    gc          :call <SID>ToggleComment()<CR>
vnoremap    J           :m '>+1<CR>gv=gv| " move seleção pra baixo
vnoremap    K           :m '<-2<CR>gv=gv| " move seleção pra cima
inoremap    kj          <esc>|" esc mais fácil
nnoremap    n           nzzzv|" centraliza match do search
nnoremap    N           Nzzzv|" centraliza match do search
vnoremap    a'          c'<c-r>"'|" surround match
vnoremap    a"          c"<c-r>""|" surround match
vnoremap    a(          c(<c-r>")|" surround match
vnoremap    a{          c{<c-r>"}|" surround match
vnoremap    a[          c[<c-r>"]|" surround match
nnoremap    Q           @q
tnoremap    <esc>       <C-\><C-n>
noremap     \           za|" toggle fold
nnoremap    <expr><f2>  &foldlevel ? 'zM' :'zR'| " Toggle fold todo arquivo
noremap     <up>        <nop>|" força hjkl
noremap     <down>      <nop>|" força hjkl
noremap     <left>      <nop>|" força hjkl
noremap     <right>     <nop>|" força hjkl
inoremap    <up>        <nop>|" força hjkl
inoremap    <down>      <nop>|" força hjkl
inoremap    <left>      <nop>|" força hjkl
inoremap    <right>     <nop>|" força hjkl
nnoremap    <c-\>       <c-]>|" teclado brasileiro <c-]> não funciona
inoremap    <c-a>       <C-O>yiW<End>=<C-R>=<C-R>0<CR>| " tip 73 (vim.fandom)
inoremap    <c-h>       <left>|" força hjkl
cnoremap    <c-h>       <left>
inoremap    <c-j>       <down>|" força hjkl
nnoremap    <c-j>       <c-w>w|" estilo DWM
inoremap    <c-k>       <up>|" força hjkl
nnoremap    <c-k>       <c-w>W|" estilo DWM
cnoremap    <c-l>       <right>
inoremap    <c-l>       <right>|" força hjkl
tnoremap    <c-l>       cls<cr>
nnoremap    <c-n>       yiwV| " substitue mult cursors
xnoremap    <c-n>       :s/<c-r><c-*>//g<left><left>| " substitue mult cursors
inoremap    <c-q>       <esc>:call JumpToTag()<cr>| " <++>
nnoremap    <c-q>       :call JumpToTag()<cr>| " <++>
nnoremap    <c-s>       mi<esc>gg=G`i|" indenta todo o arquivo
nnoremap    <c-z>       <nop>
inoremap    <c-z>       <c-r>=<SID>AutoCompleteCarinhas()<CR>
tnoremap    <s-insert>  <c-w>"*
tnoremap    <c-s-v>     <c-w>"*

"## Abreviações
"wtf-abbr

cnoreabbrev W! w!
cnoreabbrev Q! q!
cnoreabbrev Qa! qa!
cnoreabbrev QA! qa!
cnoreabbrev Wq wq
cnoreabbrev Wa wa
cnoreabbrev wQ wq
cnoreabbrev WQ wq
cnoreabbrev W w
cnoreabbrev Q q
cnoreabbrev Qa qa
cnoreabbrev QA qa
cnoreabbrev Wqa wqa
cnoreabbrev WQa wqa
cnoreabbrev WQA wqa
cnoreabbrev wQA wqa
cnoreabbrev wqA wqa
cnoreabbrev wQa wqa

cabbrev cvimgrep
            \ noautocmd vim /\<lt><C-R><C-W>\>/g
            \ **/*<C-R>=(expand("%:e")=="" ? "" : ".".expand("%:e"))<CR>
            \ <Bar> cope
            \ <C-Left><C-Left><C-Left>

cabbrev clvimgrep
            \ noautocmd lvim /\<lt><C-R><C-W>\>/g
            \ <C-R>=(expand("%"))<CR>
            \ <Bar> lop
            \ <C-Left><C-Left><C-Left>

"## AutoCmds
"wtf-autocmd

" FIXME Como colocar definição de filetype em ftdetect?
augroup filetype_detect
    au!
    au BufRead,BufNewFile *.phtml setfiletype html
    au BufRead,BufNewFile *.gv setfiletype dot
augroup END
